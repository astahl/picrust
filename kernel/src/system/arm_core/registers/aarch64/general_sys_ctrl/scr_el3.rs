use mystd::bit_field;

use crate::system_register_impl;

system_register_impl!(scr_el3 ScrEl3 (r,w));
bit_field!(
    /// # D19.2.120 SCR_EL3, Secure Configuration Register
    /// Defines the configuration of the current Security state. It specifies:
    /// * The Security state of EL0, EL1, and EL2. The Security state is Secure, Non-secure, or Realm.
    /// * The Execution state at lower Exception levels.
    /// * Whether IRQ, FIQ, SError interrupts, and External abort exceptions are taken to EL3.
    /// * Whether various operations are trapped to EL3.
    pub ScrEl3 (u64) {
    /// # NSE, bit \[62\]
    /// 
    /// ## When FEAT_RME is implemented:
    /// This field, evaluated with SCR_EL3.NS, selects the Security state of EL2 and lower Exception levels.
    /// For a description of the values derived by evaluating NS and NSE together, see SCR_EL3.NS. The reset behavior of this field is:
    /// 
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0, and the Effective value of this bit is 0b0.
    #[cfg(feature = "feat_rme")]
    62 => nse,

    /// # MECEn, bit \[49]
    /// ## When FEAT_MEC is implemented:
    /// Enables access to the following EL2 MECID registers, from EL2:
    /// 
    /// * MECID_P0_EL2.
    /// * MECID_A0_EL2
    /// * MECID_P1_EL2
    /// * MECID_A1_EL2
    /// * VMECID_P_EL2
    /// * VMECID_A_EL2
    /// 
    /// Accesses to these registers are trapped and reported using an ESR_EL3.EC value of 0x18.
    /// 
    /// * 0b0 Accesses from EL2 to a listed MECID register are trapped to EL3. The value of a listed EL2 MECID register is treated as 0 for all purposes other than direct reads or writes to the register from EL3.
    /// * 0b1 This control does not cause any instructions to be trapped.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_mec")]
    49 => mece_n,

    /// GPF, bit \[48]
    /// 
    /// ## When FEAT_RME is implemented:
    /// 
    /// Controls the reporting of Granule protection faults at EL0, EL1 and EL2.
    /// 
    /// * 0b0 This control does not cause exceptions to be routed from EL0, EL1 or EL2 to EL3.
    /// * 0b1 GPFs at EL0, EL1 and EL2 are routed to EL3 and reported as Granule Protection Check exceptions.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0
    #[cfg(feature = "feat_rme")]
    48 => gpf,

    /// # SCTLR2En, bit \[44]
    /// ## When FEAT_SCTLR2 is implemented:
    /// SCTLR2_ELx register trap control. Enables access to SCTLR2_EL1 and SCTLR2_EL2 registers.
    /// 
    /// * 0b0 EL1 and EL2 accesses to SCTLR2_EL1 and SCTLR2_EL2 registers are disabled, and trapped to EL3. The values in these registers are treated as 0.
    /// * 0b1 This control does not cause any instructions to be trapped.
    /// 
    /// Traps are reported using an ESR_EL3.EC value of 0x18.
    /// 
    /// Traps are not taken if there is a higher priority exception generated by the access. 
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_sctlr2")]
    44 => sctlr2_en,

    /// # TCR2En, bit \[43]
    /// ## When FEAT_TCR2 is implemented:
    /// TCR2_ELx register trap control. Enables access to TCR2_EL1 and TCR2_EL2 registers.
    /// 
    /// * 0b0 EL1 and EL2 accesses to TCR2_EL1 and TCR2_EL2 registers are disabled, and trapped to EL3. The values in these registers are treated as 0.
    /// * 0b1 This control does not cause any instructions to be trapped.
    /// 
    /// Traps are reported using an ESR_EL3.EC value of 0x18.
    /// 
    /// Traps are not taken if there is a higher priority exception generated by the access. 
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_tcr2")]
    43 => tcr2_en,

    /// # EnTP2, bit \[41]
    /// ## When FEAT_SME is implemented:
    /// Traps instructions executed at EL2, EL1, and EL0 that access TPIDR2_EL0 to EL3. 
    /// The exception is reported using ESR_ELx.EC value 0x18.
    /// 
    /// * 0b0 This control causes execution of these instructions at EL2, EL1, and EL0 to be trapped.
    /// * 0b1 This control does not cause execution of any instructions to be trapped.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_rme")]
    41 => en_tp2,

    /// # TRNDR, bit \[40]
    /// ## When FEAT_RNG_TRAP is implemented:
    /// Controls trapping of reads of RNDR and RNDRRS. The exception is reported using ESR_ELx.EC value 0x18.
    /// * 0b0 This control does not cause RNDR and RNDRRS to be trapped. 
    ///     - When FEAT_RNG is implemented: ID_AA64ISAR0_EL1.RNDR returns the value 0b0001. 
    ///     - When FEAT_RNG is not implemented: ID_AA64ISAR0_EL1.RNDR returns the value 0b0000.
    ///     - MRS reads of RNDR and RNDRRS are UNDEFINED.
    /// * 0b1 ID_AA64ISAR0_EL1.RNDR returns the value 0b0001. Any attempt to read RNDR or RNDRRS is trapped to EL3.
    /// 
    /// When FEAT_RNG is not implemented, Arm recommends that SCR_EL3.TRNDR is initialized before entering Exception levels below EL3 and not subsequently changed.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to 0.
    ///
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_rng_trap")]
    40 => trndr,

    /// # HXEn, bit \[38]
    /// ## When FEAT_HCX is implemented:
    /// Enables access to the HCRX_EL2 register at EL2 from EL3.
    /// 
    /// * 0b0 Accesses at EL2 to HCRX_EL2 are trapped to EL3. Indirect reads of HCRX_EL2
    /// return 0.
    /// * 0b1 This control does not cause any instructions to be trapped.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_hcx")]
    38 => hx_en,

    /// # ADEn, bit \[37]
    /// ## When FEAT_LS64_ACCDATA is implemented:
    /// Enables access to the ACCDATA_EL1 register at EL1 and EL2.
    /// 
    /// * 0b0 Accesses to ACCDATA_EL1 at EL1 and EL2 are trapped to EL3, unless the accesses
    /// are trapped to EL2 by the EL2 fine-grained trap.
    /// * 0b1 This control does not cause accesses to ACCDATA_EL1 to be trapped.
    /// 
    /// If the HFGWTR_EL2.nACCDATA_EL1 or HFGRTR_EL2.nACCDATA_EL1 traps are enabled, they take priority over this trap.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_ls64_accdata")]
    37 => ad_en,

    /// # EnAS0, bit \[36]
    /// ## When FEAT_LS64_ACCDATA is implemented:
    /// Traps execution of an ST64BV0 instruction at EL0, EL1, or EL2 to EL3.
    /// * 0b0 
    ///     - EL0 execution of an ST64BV0 instruction is trapped to EL3, unless it is trapped to EL1 by SCTLR_EL1.EnAS0, or to EL2 by either HCRX_EL2.EnAS0 or SCTLR_EL2.EnAS0.
    ///     - EL1 execution of an ST64BV0 instruction is trapped to EL3, unless it is trapped to EL2 by HCRX_EL2.EnAS0.
    ///     - EL2 execution of an ST64BV0 instruction is trapped to EL3. 
    /// * 0b1 
    ///     - This control does not cause any instructions to be trapped.
    /// 
    /// A trap of an ST64BV0 instruction is reported using an ESR_ELx.EC value of 0x0A, with an ISS code of 0x0000001.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_ls64_accdata")]
    37 => en_as0,

    /// # AMVOFFEN, bit \[35]
    /// ## When FEAT_AMUv1p1 is implemented:
    /// Activity Monitors Virtual Offsets Enable.
    /// * 0b0 Accesses to AMEVCNTVOFF0\<n>_EL2 and AMEVCNTVOFF1\<n>_EL2 at EL2 are trapped to EL3. Indirect reads of the virtual offset registers are zero.
    /// * 0b1 Accesses to AMEVCNTVOFF0\<n>_EL2 and AMEVCNTVOFF1\<n>_EL2 are not affected by this field.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_amuv1p1")]
    35 => amvoff_en,

    /// # TME, bit \[34]
    /// ## When FEAT_TME is implemented:
    /// Enables access to the TSTART, TCOMMIT, TTEST and TCANCEL instructions at EL0, EL1 and EL2.
    /// * 0b0 EL0, EL1 and EL2 accesses to TSTART, TCOMMIT, TTEST and TCANCEL instructions are UNDEFINED.
    /// * 0b1 This control does not cause any instruction to be UNDEFINED.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_tme")]
    34 => tme,

    /// # TWEDEL, bits \[33:30]
    /// ## When FEAT_TWED is implemented:
    /// TWE Delay. A 4-bit unsigned number that, when SCR_EL3.TWEDEn is 1, encodes the minimum delay in taking a trap of WFE* caused by SCR_EL3.TWE as 2(TWEDEL + 8) cycles.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_twed")]
    33:30 => twedel,

    /// # TWEDEn, bit \[29]
    /// ## When FEAT_TWED is implemented:
    /// TWE Delay Enable. Enables a configurable delayed trap of the WFE* instruction caused by SCR_EL3.TWE.
    /// 
    /// Traps are reported using an ESR_ELx.EC value of 0x01.
    /// 
    /// * 0b0 The delay for taking the trap is IMPLEMENTATION DEFINED.
    /// * 0b1 The delay for taking the trap is at least the number of cycles defined in SCR_EL3.TWEDEL.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_twed")]
    29 => tweden,

    /// # ECVEn, bit \[28]
    /// ## When FEAT_ECV is implemented:
    /// ECV Enable. Enables access to the CNTPOFF_EL2 register.
    /// * 0b0 EL2 accesses to CNTPOFF_EL2 are trapped to EL3, and the value of CNTPOFF_EL2
    /// is treated as 0 for all purposes other than direct reads or writes to the register from EL3.
    /// * 0b1 EL2 accesses to CNTPOFF_EL2 are not trapped to EL3 by this mechanism.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_ecv")]
    38 => ecv_en,

    /// # FGTEn, bit \[27]
    /// ## When FEAT_FGT is implemented:
    /// Fine-Grained Traps Enable. When EL2 is implemented, enables the traps to EL2 controlled by HAFGRTR_EL2, HDFGRTR_EL2, HDFGWTR_EL2, HFGRTR_EL2, HFGITR_EL2, and HFGWTR_EL2, and controls access to those registers.
    /// 
    /// > ### Note
    /// > If EL2 is not implemented but EL3 is implemented, FEAT_FGT implements the MDCR_EL3.TDCC traps.
    /// 
    /// * 0b0 EL2 accesses to HAFGRTR_EL2, HDFGRTR_EL2, HDFGWTR_EL2, HFGRTR_EL2, HFGITR_EL2 and HFGWTR_EL2 registers are trapped to EL3, and the traps to EL2 controlled by those registers are disabled.
    /// * 0b1 EL2 accesses to HAFGRTR_EL2, HDFGRTR_EL2, HDFGWTR_EL2, HFGRTR_EL2, HFGITR_EL2 and HFGWTR_EL2 registers are not trapped to EL3 by this mechanism.
    /// 
    /// Traps caused by accesses to the fine-grained trap registers are reported using an ESR_ELx.EC value of 0x18 and its associated ISS.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_fgt")]
    27 => fgt_en,

    /// # ATA, bit \[26]
    /// ## When FEAT_MTE2 is implemented:
    /// Allocation Tag Access. Controls access to Allocation Tags, System registers for Memory tagging, and prevention of Tag checking, at EL2, EL1 and EL0.
    /// * 0b0 
    ///     - Access to Allocation Tags is prevented at EL2, EL1, and EL0.
    ///     - Accesses at EL1 and EL2 to GCR_EL1, RGSR_EL1, TFSR_EL1, TFSR_EL2 or TFSRE0_EL1 that are not UNDEFINED or trapped to a lower Exception level are trapped to EL3.
    ///     - Accesses at EL2 using MRS or MSR with the register name TFSR_EL12 that are not UNDEFINED are trapped to EL3.
    ///     - Memory accesses at EL2, EL1, and EL0 are not subject to a Tag Check operation.
    /// * 0b1 
    ///     - This control does not prevent access to Allocation Tags at EL2, EL1, and EL0. 
    ///     - This control does not prevent Tag checking at EL2, EL1, and EL0.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_mte2")]
    26 => ata,

    /// # EnSCXT, bit \[25]
    /// ## When FEAT_CSV2_2 is implemented or FEAT_CSV2_1p2 is implemented:
    /// Enables access to the SCXTNUM_EL2, SCXTNUM_EL1, and SCXTNUM_EL0 registers.
    /// * 0b0 Accesses at EL0, EL1 and EL2 to SCXTNUM_EL0, SCXTNUM_EL1, or SCXTNUM_EL2 registers are trapped to EL3 if they are not trapped by a higher priority exception, and the values of these registers are treated as 0.
    /// * 0b1 This control does not cause any accesses to be trapped, or register values to be treated as 0.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(any(feature = "feat_csv2_2", feature = "feat_csv2_1p2"))]
    25 => en_scxt,

    /// # FIEN, bit \[21]
    /// ## When FEAT_RASv1p1 is implemented:
    /// Fault Injection enable. Trap accesses to the registers ERXPFGCDN_EL1, ERXPFGCTL_EL1, and ERXPFGF_EL1 from EL1 and EL2 to EL3, reported using an ESR_ELx.EC value of 0x18.
    /// 
    /// * 0b0 Accesses to the specified registers from EL1 and EL2 generate a Trap exception to EL3.
    /// * 0b1 This control does not cause any instructions to be trapped.
    /// 
    /// If EL3 is not implemented, the Effective value of SCR_EL3.FIEN is 0b1.
    /// 
    /// If ERRIDR_EL1.NUM is zero, meaning no error records are implemented, or no error record accessible using System registers is owned by a node that implements the RAS Common Fault Injection Model Extension, then this bit might be RES0.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_rasv1p1")]
    21 => fien, 

    /// # NMEA, bit \[20]
    /// ## When FEAT_DoubleFault is implemented:
    /// Non-maskable External Aborts. Controls whether PSTATE.A masks SError exceptions at EL3.
    /// * 0b0 SError exceptions are not taken at EL3 if PSTATE.A == 1.
    /// * 0b1 SError exceptions are taken at EL3 regardless of the value of PSTATE.A.
    /// 
    /// This field is ignored by the PE and treated as zero when SCR_EL3.EA == 0.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to 0. 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_doublefault")]
    20 => nmea,

    /// # EASE, bit \[19]
    /// ## When FEAT_DoubleFault is implemented:
    /// External aborts to SError interrupt vector.
    /// * 0b0 Synchronous External abort exceptions taken to EL3 are taken to the appropriate
    /// synchronous exception vector offset from VBAR_EL3.
    /// * 0b1 Synchronous External abort exceptions taken to EL3 are taken to the appropriate SError
    /// interrupt vector offset from VBAR_EL3. 
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to 0. 
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_doublefault")]
    19 => ease,

    /// # EEL2, bit \[18]
    /// ## When FEAT_SEL2 is implemented:
    /// Secure EL2 Enable.
    /// * 0b0 All behaviors associated with Secure EL2 are disabled. All registers, including timer registers, defined by FEAT_SEL2 are UNDEFINED, and those timers are disabled.
    /// * 0b1 All behaviors associated with Secure EL2 are enabled. 
    /// 
    /// When the value of this bit is 1, then:
    /// 
    /// * When SCR_EL3.NS == 0, the SCR_EL3.RW bit is treated as 1 for all purposes other than reading or writing the register.
    /// * If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2, using the EC value of ESR_EL2.EC== 0x3 :
    ///     - A read or write of the SCR.
    ///     - A read or write of the NSACR.
    ///     - A read or write of the MVBAR.
    ///     - A read or write of the SDCR.
    ///     - Execution of an ATS12NSO** instruction.
    /// * If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2 using the EC value of ESR_EL2.EC== 0x0 :
    ///     - Execution of an SRS instruction that uses R13_mon.
    ///     - Execution of an MRS (Banked register) or MSR (Banked register) instruction that would access SPSR_mon, R13_mon, or R14_mon. 
    /// > ### Note
    /// > If the Effective value of SCR_EL3.EEL2 is 0, then these operations executed in Secure EL1 using AArch32 are trapped to EL3.
    /// 
    /// A Secure only implementation that does not implement EL3 but implements EL2, behaves as if SCR_EL3.EEL2 == 1.
    /// 
    /// This bit is permitted to be cached in a TLB.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_sel2")]
    18 => eel2,

    /// # API, bit \[17]
    /// ## When FEAT_SEL2 is implemented and FEAT_PAuth is implemented:
    /// Controls the use of the following instructions related to Pointer Authentication. Traps are reported using an ESR_ELx.EC value of 0x09:
    /// 
    /// * PACGA, which is always enabled.
    /// * AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZB, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:
    ///     - In EL0, when HCR_EL2.TGE == 0 or HCR_EL2.E2H == 0, and the associated SCTLR_EL1.En\<N>\<M> == 1.
    ///     - In EL0, when HCR_EL2.TGE == 1 and HCR_EL2.E2H == 1, and the associated SCTLR_EL2.En\<N>\<M> == 1.
    ///     - In EL1, when the associated SCTLR_EL1.En\<N>\<M> == 1.
    ///     - In EL2, when the associated SCTLR_EL2.En\<N>\<M> == 1.
    /// 
    /// * 0b0 
    ///     - The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.API bit.
    /// * 0b1 
    ///     - This control does not cause any instructions to be trapped.
    /// 
    /// An instruction is trapped only if Pointer Authentication is enabled for that instruction, for more
    /// information, see PAC generation and verification keys on page D8-5897. 
    /// 
    /// > ### Note
    /// > If FEAT_PAuth is implemented but EL3 is not implemented, the system behaves as if this bit is 1.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## When FEAT_SEL2 is not implemented and FEAT_PAuth is implemented:
    /// Controls the use of instructions related to Pointer Authentication:
    /// * PACGA.
    /// * AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZ, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:
    ///     - In Non-secure EL0, when HCR_EL2.TGE == 0 or HCR_EL2.E2H == 0, and the associated SCTLR_EL1.En\<N>\<M>== 1.
    ///     - In Non-secure EL0, when HCR_EL2.TGE == 1 and HCR_EL2.E2H == 1, and the associated SCTLR_EL2.En\<N>\<M> == 1.
    ///     - In Secure EL0, when the associated SCTLR_EL1.En\<N>\<M> == 1.
    ///     - In Secure or Non-secure EL1, when the associated SCTLR_EL1.En\<N>\<M> == 1. In EL2, when the associated SCTLR_EL2.En\<N>\<M> == 1.
    /// 
    /// * 0b0 
    ///     - The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.API bit.
    /// * 0b1 
    ///     - This control does not cause any instructions to be trapped.
    ///
    /// If FEAT_PAuth is implemented but EL3 is not implemented, the system behaves as if this bit is 1.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_pauth")]
    17 => api,

    /// # APK, bit \[16]
    /// ## When FEAT_PAuth is implemented:
    /// Trap registers holding "key" values for Pointer Authentication. Traps accesses to the following registers, using an ESR_ELx.EC value of 0x18, from EL1 or EL2 to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.APK bit or other traps:
    /// * APIAKeyLo_EL1, APIAKeyHi_EL1, APIBKeyLo_EL1, APIBKeyHi_EL1.
    /// * APDAKeyLo_EL1, APDAKeyHi_EL1, APDBKeyLo_EL1, APDBKeyHi_EL1.
    /// * APGAKeyLo_EL1, and APGAKeyHi_EL1.
    ///
    /// * 0b0 
    ///     - Access to the registers holding "key" values for pointer authentication from EL1 or EL2 are trapped to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.APK bit or other traps.
    /// * 0b1 
    ///     - This control does not cause any instructions to be trapped.
    /// 
    /// For more information, see PAC generation and verification keys on page D8-5897.
    /// 
    /// > ### Note
    /// > If FEAT_PAuth is implemented but EL3 is not implemented, the system behaves as if this bit is 1.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_pauth")]
    16 => apk,

    /// # TERR, bit \[15]
    /// ## When FEAT_RAS is implemented:
    /// Trap accesses of error record registers. Enables a trap to EL3 on accesses of error record registers.
    /// * 0b0 
    ///     - Accesses of the specified error record registers are not trapped by this mechanism.
    /// * 0b1 
    ///     - Accesses of the specified error record registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.
    /// 
    /// In AArch64 state, the instructions affected by this control are:
    /// * MRS and MSR accesses to ERRSELR_EL1, ERXADDR_EL1, ERXCTLR_EL1, ERXMISC0_EL1, ERXMISC1_EL1, and ERXSTATUS_EL1.
    /// * MRS accesses to ERRIDR_EL1 and ERXFR_EL1.
    /// * If FEAT_RASv1p1 is implemented, MRS and MSR accesses to ERXMISC2_EL1 and ERXMISC3_EL1.
    /// 
    /// In AArch32 state, the instructions affected by this control are:
    /// * MRC and MCR accesses to ERRSELR, ERXADDR, ERXADDR2, ERXCTLR, ERXCTLR2, ERXMISC0, ERXMISC1, ERXMISC2, ERXMISC3, and ERXSTATUS.
    /// * MRC accesses to ERRIDR, ERXFR, and ERXFR2.
    /// * If FEAT_RASv1p1 is implemented, MRC and MCR accesses to ERXMISC4, ERXMISC5, ERXMISC6, and ERXMISC7.
    /// 
    /// Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.
    /// 
    /// Trapped AArch64 instructions are reported using EC syndrome value 0x18. Trapped AArch32 instructions are reported using EC syndrome value 0x03. Accessing this field has the following behavior:
    /// * This field is permitted to be RES0 if all of the following are true:
    ///     - ERRSELR_EL1 and all ERX* registers are implemented as UNDEFINED or RAZ/WI.
    ///     - ERRIDR_EL1.NUM is zero.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_ras")]
    15 => terr,

    /// # TLOR, bit \[14]
    /// ## When FEAT_LOR is implemented:
    /// Trap LOR registers. Traps accesses to the LORSA_EL1, LOREA_EL1, LORN_EL1, LORC_EL1, and LORID_EL1 registers from EL1 and EL2 to EL3, unless the access has been trapped to EL2.
    /// 
    /// * 0b0 
    ///     - This control does not cause any instructions to be trapped.
    /// * 0b1 
    ///     - EL1 and EL2 accesses to the LOR registers that are not UNDEFINED are trapped to EL3, unless it is trapped HCR_EL2.TLOR.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// ## Otherwise:
    /// Reserved, RES0.
    #[cfg(feature = "feat_lor")]
    14 => tlor,
    
    /// # TWE, bit \[13]
    /// 
    /// Traps EL2, EL1, and EL0 execution of WFE instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of 0x01.
    /// 
    /// When FEAT_WFxT is implemented, this trap also applies to the WFET instruction.
    /// * 0b0 
    ///     - This control does not cause any instructions to be trapped.
    /// * 0b1 
    ///     - Any attempt to execute a WFE instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by SCTLR.nTWE, HCR.TWE, SCTLR_EL1.nTWE, SCTLR_EL2.nTWE, or HCR_EL2.TWE.
    /// 
    /// In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.
    /// 
    /// > ### Note
    /// > Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.
    /// 
    /// For more information about when WFE instructions can cause the PE to enter a low-power state, see Wait for Event on page D1-5395.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    13 => twe,
    
    /// # TWI, bit \[12]
    /// Traps EL2, EL1, and EL0 execution of WFI instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of 0x01.
    /// When FEAT_WFxT is implemented, this trap also applies to the WFIT instruction.
    /// 0b0 This control does not cause any instructions to be trapped.
    /// 0b1 Any attempt to execute a WFI instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by SCTLR.nTWI, HCR.TWI, SCTLR_EL1.nTWI, SCTLR_EL2.nTWI, or HCR_EL2.TWI.
    /// In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.
    /// AArch64 System Register Descriptions D19.2 General system control registers
    /// 
    /// > ### Note
    /// > Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.
    /// 
    /// For more information about when WFI instructions can cause the PE to enter a low-power state, see Wait for Interrupt mechanism on page D1-5397.
    /// The reset behavior of this field is:
    /// • On a Warm reset, this field resets to an architecturally UNKNOWN value.
    12 => twi,

    /// # ST, bit \[11]
    /// Traps Secure EL1 accesses to the Counter-timer Physical Secure timer registers to EL3, from AArch64 state only, reported using an ESR_ELx.EC value of 0x18.
    /// 0b0 Secure EL1 using AArch64 accesses to the CNTPS_TVAL_EL1, CNTPS_CTL_EL1, and CNTPS_CVAL_EL1 are trapped to EL3 when Secure EL2 is disabled. If Secure EL2 is enabled, the behavior is as if the value of this field was 0b1.
    /// 0b1 This control does not cause any instructions to be trapped. Note
    /// Accesses to the Counter-timer Physical Secure timer registers are always enabled at EL3. These registers are not accessible at EL0.
    /// When FEAT_RME is implemented and Secure state is not implemented, this bit is RES0. The reset behavior of this field is:
    /// • On a Warm reset, this field resets to an architecturally UNKNOWN value.
    11 => st,

    /// # RW, bit \[10]
    /// When EL1 is capable of using AArch32 or EL2 is capable of using AArch32:
    /// Execution state control for lower Exception levels. 
    /// * 0b0 
    ///     - Lower levels are all AArch32.
    /// * 0b1 
    ///     - The next lower level is AArch64.
    ///     - If EL2 is present:
    ///         - EL2 is AArch64.
    ///         - EL2 controls EL1 and EL0 behaviors.
    ///     - If EL2 is not present:
    ///         - EL1 is AArch64.
    ///         - EL0 is determined by the Execution state described in the current process state when executing at EL0.
    /// 
    /// If AArch32 state is supported by the implementation at EL1, SCR_EL3.NS == 1 and AArch32 state is not supported by the implementation at EL2, the Effective value of this bit is 1.
    /// 
    /// If AArch32 state is supported by the implementation at EL1, FEAT_SEL2 is implemented and SCR_EL3.{EEL2, NS} == {1, 0}, the Effective value of this bit is 1.
    /// 
    /// This bit is permitted to be cached in a TLB.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ### Otherwise:
    /// Reserved, RAO/WI.
    10 => rw,

    /// # SIF, bit \[9]
    /// Secure instruction fetch. When the PE is in Secure state, this bit disables instruction execution from memory marked in the first stage of translation as being Non-secure.
    /// 
    /// * 0b0 
    ///     - Secure state instruction execution from memory marked in the first stage of translation as being Non-secure is permitted.
    /// * 0b1 
    ///     - Secure state instruction execution from memory marked in the first stage of translation as being Non-secure is not permitted.
    /// 
    /// When FEAT_RME is implemented and Secure state is not implemented, this bit is RES0.
    /// 
    /// When FEAT_PAN3 is implemented, it is IMPLEMENTATION DEFINED whether SCR_EL3.SIF is also
    /// used to determine instruction access permission for the purpose of PAN.
    /// 
    /// This bit is permitted to be cached in a TLB.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    9 => sif,

    /// # HCE, bit \[8]
    /// Hypervisor Call instruction enable. Enables HVC instructions at EL3 and, if EL2 is enabled in the current Security state, at EL2 and EL1, in both Execution states, reported using an ESR_ELx.EC value of 0x00.
    /// * 0b0 
    ///     - HVC instructions are UNDEFINED.
    /// * 0b1 
    ///     - HVC instructions are enabled at EL3, EL2, and EL1.
    /// > ### Note
    /// > HVC instructions are always UNDEFINED at EL0 and, if Secure EL2 is disabled, at Secure EL1. Any resulting exception is taken from the current Exception level to the current Exception level.
    /// 
    /// If EL2 is not implemented, this bit is RES0.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    8 => hce,

    /// # SMD, bit \[7]
    /// Secure Monitor Call disable. Disables SMC instructions at EL1 and above, from any Security state and both Execution states, reported using an ESR_ELx.EC value of 0x00.
    /// * 0b0 
    ///     - SMC instructions are enabled at EL3, EL2 and EL1. 
    /// * 0b1 
    ///     - SMC instructions are UNDEFINED.
    /// 
    /// > ### Note
    /// > SMC instructions are always UNDEFINED at EL0. Any resulting exception is taken from the current Exception level to the current Exception level.
    /// 
    /// If HCR_EL2.TSC or HCR.TSC traps attempted EL1 execution of SMC instructions to EL2, that trap has priority over this disable.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    7 => smd,

    5:4 => res1 = 0b11,

    /// # EA, bit \[3]
    /// External Abort and SError interrupt routing.
    /// * 0b0 
    ///     - When executing at Exception levels below EL3, External aborts and SError interrupts are not taken to EL3.
    ///     - In addition, when executing at EL3:
    ///         - SError interrupts are not taken.
    ///         - External aborts are taken to EL3.
    /// * 0b1 
    ///     - When executing at any Exception level, External aborts and SError interrupts are taken to EL3.
    /// 
    /// For more information, see Establishing the target Exception level of an asynchronous exception on page D1-5376.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    3 => ea,

    /// # FIQ, bit \[2]
    /// Physical FIQ Routing.
    /// * 0b0 
    ///     - When executing at Exception levels below EL3, physical FIQ interrupts are not taken to EL3.
    ///     - When executing at EL3, physical FIQ interrupts are not taken.
    /// * 0b1 
    ///     - When executing at any Exception level, physical FIQ interrupts are taken to EL3.
    /// 
    /// For more information, see Establishing the target Exception level of an asynchronous exception on page D1-5376.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    2 => fiq,

    /// # IRQ, bit \[1]
    /// Physical IRQ Routing.
    /// * 0b0 
    ///     - When executing at Exception levels below EL3, physical IRQ interrupts are not taken to EL3.
    ///     - When executing at EL3, physical IRQ interrupts are not taken.
    /// * 0b1 
    ///     - When executing at any Exception level, physical IRQ interrupts are taken to EL3.
    /// 
    /// For more information, see Establishing the target Exception level of an asynchronous exception on page D1-5376.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    1 => irq,  

    /// # NS, bit \[0]
    /// When FEAT_RME is implemented:
    /// Non-secure bit. This field is used in combination with SCR_EL3.NSE to select the Security state of EL2 and lower Exception levels.
    /// NSE     NS  Meaning
    /// 0b0     0b0 Secure.
    /// 0b0     0b1 Non-secure.
    /// 0b1     0b0 Reserved.
    /// 0b1     0b1 Realm.
    /// 
    /// When Secure state is not implemented, SCR_EL3.NS is RES1 and its effective value is 1.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    /// 
    /// ## Otherwise:
    /// Non-secure bit.
    /// 0b0 Indicates that EL0 and EL1 are in Secure state.
    /// When FEAT_SEL2 is implemented and SCR_EL3.EEL2 == 1, then EL2 is using AArch64 and in Secure state.
    /// 0b1 Indicates that Exception levels lower than EL3 are in Non-secure state, so memory accesses from those Exception levels cannot access Secure memory.
    /// 
    /// The reset behavior of this field is:
    /// * On a Warm reset, this field resets to an architecturally UNKNOWN value.
    0 => ns,  
});